// Decompiled with JetBrains decompiler
// Type: VanillaQuestsExpandedCryptoforge.QuestNode_Site
// Assembly: VanillaQuestsExpandedCryptoforge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2EB4E694-B7D1-4E94-B7E3-FD665CFCBE15
// Assembly location: C:\Program Files (x86)\Steam\steamapps\workshop\content\294100\3461526070\1.6\Assemblies\VanillaQuestsExpandedCryptoforge.dll

using RimWorld;
using RimWorld.Planet;
using RimWorld.QuestGen;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Verse;
using Verse.Grammar;

#nullable disable
namespace VanillaQuestsExpandedCryptoforge;

public abstract class QuestNode_Site : QuestNode
{
  public abstract SitePartDef QuestSite { get; }

  protected bool TryFindSiteTile(
    out int tile,
    Predicate<int> extraValidator = null,
    List<BiomeDef> allowedBiomes = null)
  {
    if (allowedBiomes != null && !Find.WorldGrid.Tiles.Any<SurfaceTile>((Func<SurfaceTile, bool>) (x => allowedBiomes.Contains(((Tile) x).PrimaryBiome))))
      allowedBiomes = (List<BiomeDef>) null;
    if (GenCollection.TryRandomElement<int>(Find.World.tilesInRandomOrder.Tiles.Where<int>((Func<int, bool>) (x => (extraValidator == null || extraValidator(x)) && QuestNode_Site.IsValidTile(x, allowedBiomes))), ref tile))
      return true;
    tile = -1;
    return false;
  }

  public static bool IsValidTile(int tile, List<BiomeDef> allowedBiomes = null)
  {
    Tile tile1 = (Tile) Find.WorldGrid[tile];
    return tile1.PrimaryBiome.canBuildBase && tile1.PrimaryBiome.implemented && tile1.hilliness != 5 && !Find.WorldObjects.AnyMapParentAt(PlanetTile.op_Implicit(tile)) && Current.Game.FindMap(PlanetTile.op_Implicit(tile)) == null && !Find.WorldObjects.AnyWorldObjectOfDefAt(WorldObjectDefOf.AbandonedSettlement, PlanetTile.op_Implicit(tile)) && (allowedBiomes == null || allowedBiomes.Count <= 0 || allowedBiomes.Contains(tile1.PrimaryBiome));
  }

  protected virtual bool TestRunInt(Slate slate) => this.TryFindSiteTile(out int _);

  protected Site GenerateSite(
    Quest quest,
    Slate slate,
    float points,
    int tile,
    Faction parentFaction,
    out string siteMapGeneratedSignal,
    bool failWhenMapRemoved = true)
  {
    Site site = QuestGen_Sites.GenerateSite((IEnumerable<SitePartDefWithParams>) new List<SitePartDefWithParams>()
    {
      new SitePartDefWithParams(this.QuestSite, new SitePartParams()
      {
        points = points,
        threatPoints = points
      })
    }, PlanetTile.op_Implicit(tile), parentFaction, false, (RulePack) null, (WorldObjectDef) null);
    ((MapParent) site).doorsAlwaysOpenForPlayerPawns = true;
    if (parentFaction != null && ((WorldObject) site).Faction != parentFaction)
      ((WorldObject) site).SetFaction(parentFaction);
    slate.Set<Site>("site", site, false);
    QuestGen_Sites.SpawnWorldObject(quest, (WorldObject) site, (List<ThingDef>) null, (string) null);
    string str = QuestGenUtility.HardcodedSignalWithQuestID("site.MapRemoved");
    siteMapGeneratedSignal = QuestGenUtility.HardcodedSignalWithQuestID("site.MapGenerated");
    if (failWhenMapRemoved)
      QuestGen_Signal.SignalPassActivable(quest, (Action) (() => QuestGen_End.End(quest, (QuestEndOutcome) 2, 0, (Faction) null, (string) null, (QuestPart.SignalListenMode) 0, true, false)), siteMapGeneratedSignal, str, (string) null, (IEnumerable<string>) null, (string) null, false);
    return site;
  }

  protected Faction CreateFaction(Quest quest, Slate slate, FactionDef factionDef)
  {
    FactionGeneratorParms factionGeneratorParms;
    // ISSUE: explicit constructor call
    ((FactionGeneratorParms) ref factionGeneratorParms).\u002Ector(factionDef, new IdeoGenerationParms(), new bool?(true));
    factionGeneratorParms.ideoGenerationParms = new IdeoGenerationParms(factionGeneratorParms.factionDef, false, (List<PreceptDef>) null, (List<MemeDef>) null, (List<MemeDef>) null, false, false, false, false, "", (List<StyleCategoryDef>) null, (List<DeityPreset>) null, false, "", false);
    Faction faction = FactionGenerator.NewGeneratedFaction(factionGeneratorParms);
    faction.temporary = true;
    faction.factionHostileOnHarmByPlayer = true;
    faction.neverFlee = true;
    Find.FactionManager.Add(faction);
    QuestGen_Factions.ReserveFaction(quest, faction);
    slate.Set<Faction>("parentFaction", faction, false);
    slate.Set<Faction>("siteFaction", faction, false);
    return faction;
  }

  protected bool PrepareQuest(
    out Quest quest,
    out Slate slate,
    out Map map,
    out float points,
    out int tile,
    Predicate<int> extraValidator = null,
    List<BiomeDef> allowedBiomes = null)
  {
    quest = RimWorld.QuestGen.QuestGen.quest;
    slate = RimWorld.QuestGen.QuestGen.slate;
    map = QuestGen_Get.GetMap(false, new int?(), false);
    QuestGenUtility.RunAdjustPointsForDistantFight();
    points = slate.Get<float>(nameof (points), 0.0f, false);
    slate.Set<Faction>("playerFaction", Faction.OfPlayer, false);
    slate.Set<Map>(nameof (map), map, false);
    return this.TryFindSiteTile(out tile, extraValidator, allowedBiomes);
  }

  public static List<PawnKindDef> GeneratePawnKindList(Faction faction, float points, Site site)
  {
    PawnGroupMakerParms parms = QuestNode_Site.GetParms(faction, points, site);
    float generatePawnGroup = faction.def.MinPointsToGeneratePawnGroup(parms.groupKind, parms);
    points = (double) generatePawnGroup < 3.4028234663852886E+38 ? Mathf.Max(points, generatePawnGroup) : points;
    parms.points = points;
    List<PawnKindDef> pawnKindList;
    for (pawnKindList = new List<PawnKindDef>(); !GenCollection.Any<PawnKindDef>(pawnKindList) && (double) points < 99999.0; pawnKindList = QuestNode_Site.GeneratePawnKinds(parms, false).ToList<PawnKindDef>())
    {
      points += 50f;
      parms.points = points;
    }
    return pawnKindList;
  }

  public static IEnumerable<PawnKindDef> GeneratePawnKinds(
    PawnGroupMakerParms parms,
    bool warnOnZeroResults = true)
  {
    if (parms.groupKind == null)
      Log.Error("Tried to generate pawns with null pawn group kind def. parms=" + parms?.ToString());
    else if (parms.faction == null)
      Log.Error("Tried to generate pawn kinds with null faction. parms=" + parms?.ToString());
    else if (GenList.NullOrEmpty<PawnGroupMaker>((IList<PawnGroupMaker>) parms.faction.def.pawnGroupMakers))
    {
      Log.Error($"Faction {(object) parms.faction} of def {(object) parms.faction.def} has no PawnGroupMakers.");
    }
    else
    {
      PawnGroupMaker pawnGroupMaker;
      if (PawnGroupMakerUtility.TryGetRandomPawnGroupMaker(parms, ref pawnGroupMaker, false))
      {
        foreach (PawnKindDef pawnKind in pawnGroupMaker.GeneratePawnKindsExample(parms))
          yield return pawnKind;
      }
    }
  }

  private static PawnGroupMakerParms GetParms(Faction faction, float points, Site site)
  {
    return new PawnGroupMakerParms()
    {
      groupKind = PawnGroupKindDefOf.Combat,
      tile = ((WorldObject) site).Tile,
      faction = faction,
      points = points,
      raidStrategy = RaidStrategyDefOf.ImmediateAttack
    };
  }

  protected string FormatPawnListToString(List<PawnKindDef> pawns)
  {
    return pawns == null || !GenCollection.Any<PawnKindDef>(pawns) ? "" : GenText.ToCommaList(pawns.GroupBy<PawnKindDef, PawnKindDef>((Func<PawnKindDef, PawnKindDef>) (p => p)).Select<IGrouping<PawnKindDef, PawnKindDef>, string>((Func<IGrouping<PawnKindDef, PawnKindDef>, string>) (group => $"{group.Count<PawnKindDef>()} {((Def) group.Key).label}")), false, false);
  }
}
